using Microsoft.CodeAnalysis;
using System.Reflection;
using System.Collections.Generic;
using System;
using System.IO;
using System.Text;
using System.Linq;
using System.Globalization;

namespace UnicodeDataGenerator;

[Generator]
public class UnicodeDataGenerator : ISourceGenerator
{
    public void Execute(GeneratorExecutionContext context)
    {
        const string methodName = "loadCharCodeNameMap";

        var charCodeNameMap = loadUnicodeData();
        // Find the main method
        var loadMethod = context.Compilation
            .GetSymbolsWithName(methodName, SymbolFilter.Member, context.CancellationToken)
            .FirstOrDefault()
            ?? throw new Exception($"{methodName} method not found in assembly");

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine($"namespace {loadMethod.ContainingNamespace.ToDisplayString()};");
        sb.AppendLine();
        sb.AppendLine($"public static partial class {loadMethod.ContainingType.Name}");            
        sb.AppendLine("{");
        sb.AppendLine($"    private static partial Dictionary<int, string> {loadMethod.Name}() => new Dictionary<int, string>()");
        sb.AppendLine("    {");
        
        foreach (var kvp in charCodeNameMap)
        {
            sb.AppendLine($"            [0x{kvp.Key:X2}] = \"{kvp.Value}\",");
        }

        sb.AppendLine("    };");
        sb.AppendLine("}");

        var typeName = loadMethod.ContainingType.Name;

        // Add the source code to the compilation
        context.AddSource($"{typeName}.g.cs", sb.ToString());
    }

    public void Initialize(GeneratorInitializationContext context)
    {
    }

    private Dictionary<int, string> loadUnicodeData()
    {
        var assembly = this.GetType().Assembly;
        var unicodeData = readAllLinesFromEmbeddedResource(assembly, $"{assembly.GetName().Name}.Resources.UnicodeData.txt").ToArray();
        var charCodeNameMap = new Dictionary<int, string>(65536);

        for (int i = 0; i < unicodeData.Length; i++)
        {
            var fields = unicodeData[i].Split(';');
            var charCode = int.Parse(fields[0], NumberStyles.HexNumber);
            var charName = fields[1];

            if (charCode >= 0 && charCode <= 0xFFFF)
            {
                if (charName.EndsWith(", First>"))
                {
                    charName = charName.Replace(", First", String.Empty);
                    fields = unicodeData[++i].Split(';');
                    int endCharCode = int.Parse(fields[0], NumberStyles.HexNumber);

                    if (!fields[1].EndsWith(", Last>"))
                    {
                        throw new Exception("Expected end-of-range indicator.");
                    }

                    for (int charCodeInRange = charCode; charCodeInRange <= endCharCode; charCodeInRange++)
                    {
                        charCodeNameMap.Add(charCodeInRange, charName);
                    }
                }
                else
                {
                    charCodeNameMap.Add(charCode, charName);
                }
            }
        }
        return charCodeNameMap;
    }

    private IEnumerable<string> readAllLinesFromEmbeddedResource(Assembly assembly, string resourceName, Encoding? encoding = null)
    {
        var allResources = new StringBuilder(); 
        foreach (var rsrc in assembly.GetManifestResourceNames())
        {
            allResources.AppendLine(rsrc);;
        }
        
        using var resource = assembly.GetManifestResourceStream(resourceName) 
            ?? throw new Exception($"Could not load {resourceName}.  Resources available are: {allResources}");
        using var reader = new StreamReader(resource, encoding ?? Encoding.UTF8);    
        string line;
        while ((line = reader.ReadLine()) is not null)
        {
            yield return line;
        }
    }

    // private void Legacy()
    // {

    //     // http://www.unicode.org/Public/UNIDATA/UnicodeData.txt
    //     // https://www.unicode.org/reports/tr44/#UnicodeData.txt
    //     var unicodeData = File.ReadAllLines("UnicodeData.txt", Encoding.UTF8);
    //     var charCodeNameMap = new Dictionary<int, string>(65536);

    //     for (int i = 0; i < unicodeData.Length; i++)
    //     {
    //         var fields = unicodeData[i].Split(';');
    //         var charCode = int.Parse(fields[0], NumberStyles.HexNumber);
    //         var charName = fields[1];

    //         if (charCode >= 0 && charCode <= 0xFFFF)
    //         {
    //             if (charName.EndsWith(", First>"))
    //             {
    //                 charName = charName.Replace(", First", String.Empty);
    //                 fields = unicodeData[++i].Split(';');
    //                 int endCharCode = int.Parse(fields[0], NumberStyles.HexNumber);

    //                 if (!fields[1].EndsWith(", Last>"))
    //                 {
    //                     throw new Exception("Expected end-of-range indicator.");
    //                 }

    //                 for (int charCodeInRange = charCode; charCodeInRange <= endCharCode; charCodeInRange++)
    //                 {
    //                     charCodeNameMap.Add(charCodeInRange, charName);
    //                 }
    //             }
    //             else
    //             {
    //                 charCodeNameMap.Add(charCode, charName);
    //             }
    //         }
    //     }

    //     var sb = new StringBuilder();

    //     sb.AppendLine("using System.Collections.Generic;");
    //     sb.AppendLine("");
    //     sb.AppendLine("namespace TypefaceUtil.OpenType");
    //     sb.AppendLine("{");
    //     sb.AppendLine("    public static class UnicodeData");
    //     sb.AppendLine("    {");
    //     sb.AppendLine("        public static Dictionary<int, string> CharCodeNameMap = new Dictionary<int, string>");
    //     sb.AppendLine("        {");

    //     foreach (var kvp in charCodeNameMap)
    //     {
    //         sb.AppendLine($"            [0x{kvp.Key:X2}] = \"{kvp.Value}\",");
    //     }
    //     sb.AppendLine("        };");
    //     sb.AppendLine("    }");
    //     sb.AppendLine("}");

    //     File.WriteAllText(@"..\..\..\..\src\TypefaceUtil.OpenType\UnicodeData.cs", sb.ToString());
    // }
}
